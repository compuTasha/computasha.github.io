{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/CS",
    "result": {"pageContext":{"currentCategory":"CS","categories":["All","CS","AWS","iOS","UX/UI","etc."],"edges":[{"node":{"id":"e37bcaff-dbed-5df3-b7be-0c04e89cd212","excerpt":"코세라 Kotlin for Java Developers 강의에 등장한 문제 다음 보기 4개 중에서 컴파일되지 않는 것은? : 1번, 4번   변수 f1은 반환 타입을 묻는데 null을 대입하고 있고, 변수 f4는 반환 값을 대입해야 하는데 반환 타입을 알려줌 (??) f3은 함수 대신 null로 초기화되어있기 때문에 나중에 함수 내에서 람다식을 저장하여 사용 💡 (파라미터) → 반환값  : 함수 표현식 [Kotlin] 코틀린 고차 함수 [Kotlin 강좌] 21. 고차 함수와 람다의 활용 : 네이버 블로그 (naver.com)","fields":{"slug":"/CS-nullable-difference-K/"},"frontmatter":{"categories":"CS","title":"()→Int? 와 (()→Int)? 차이점 - Kotlin","date":"February 03, 2022"}},"next":{"fields":{"slug":"/CS-callByName-callByValue/"}},"previous":null},{"node":{"id":"eb64857f-4337-5a2e-a734-835e683fe174","excerpt":"1️⃣ Call by Value (값에 의한 호출)  2️⃣ Call by Name (이름에 의한 호출)  → 그래서 이걸 어디에 쓰나요?? (예시) 리소스도 많이 들고 시간도 오래 걸리는 복잡한 연산을 하는 메소드 A가 있다. 이 메소드 A는 특정 조건이 true인 경우에 쓰이는 메소드이다. 이 메소드 A를 앞서 살펴본 1️⃣ callByValue 형식으로 호출하면 조건에 상관없이 무조건 호출되는 반면에, 2️⃣ callByName으로 호출할 시, 원하는 조건일때만 실행되도록 할 수 있다. 참고 링크 : Call by Value, Call by Name - kotlin (gitbook.io)  1️⃣ Call by Value (값에 의한 호출) 2️⃣ Call by Name (이름에 의한 호출) → 그래서 이걸 어디에 쓰나요??","fields":{"slug":"/CS-callByName-callByValue/"},"frontmatter":{"categories":"CS","title":"Call by Value, Call by Name - Kotlin","date":"February 02, 2022"}},"next":{"fields":{"slug":"/AWS-ACF-4/"}},"previous":{"fields":{"slug":"/CS-nullable-difference-K/"}}},{"node":{"id":"9b9fd21e-9bdc-52ef-ae6a-a212e184eb05","excerpt":"💫 프로그래밍 패러다임 프로그래밍 패러다임(Programming Paradigm)은 프로그래머에게 프로그래밍의 관점을 갖게 하고 코드를 어떻게 작성할지 결정하는 역할을 한다. 새로운 프로그래밍 패러다임을 통해서는 새로운 방식으로 생각하는 법을 배우게 되고, 이를 바탕으로 코드를 작성하게 된다. 명령형 프로그래밍 : 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 절차지향 프로그래밍 : 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++) 객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#) 선언형 프로그래밍 :  어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식 함수형 프로그래밍 : 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프) 명령형 프로그래밍에서는 알고리즘을 명시하고 목표는 명시 안 함. 선언형 프로그래밍에서는 알고리즘은 명시하…","fields":{"slug":"/CS-functional-programming/"},"frontmatter":{"categories":"CS","title":"프로그래밍 패러다임과 함수형 프로그래밍","date":"January 29, 2022"}},"next":{"fields":{"slug":"/AWS-seminar/"}},"previous":{"fields":{"slug":"/AWS-ACF-4/"}}},{"node":{"id":"e598ddf0-4ef0-5a4a-8127-a2302f83ad0c","excerpt":"CPU 코어 CPU = centeral Processing Unit, 중앙 처리 장치 코어 = 물리적인 CPU의 프로세서를 의미 CPU 코어의 역사 싱글 코어 👤 = 한 명이 컴퓨터에서 일한다 = 한 번에 하나씩만 처리 가능 → 한 번에 여러 개 처리하기 위해서는 현재 실행 중인 프로그램 간 전환을 빨리해서 사용자로 하여금 동시에 실행하고 있는 것처럼 느끼게 함 그전에도 멀티코어의 개념은 등장했는데 개발하지 않은 이유 1980년쯤에는 싱글 코어로도 원하는 연산 수행 충분히 가능했음 여태 만들어진 코드가 싱글 코어에서 최적의 성능을 보임 (이전 프로그램은 하나의 일을 분배해서 나누는데 시간이 더 오래걸렸음) 좀 느리다 싶으면 CPU의 클럭을 올려서(=채찍질을 더 열심히 해서) 더 빨리 계산하게 만들면 감당 가능했음 → 근데 이게 2004년도쯤 오니까 CPU가 과부화 돼서 뜨거워지기 시작함 CPU burning 🔥 → 그래서 인텔이 싱글코어 손절하고 듀얼코어 👥 로 전환 (정확히 20…","fields":{"slug":"/CS-cpu-core-thread/"},"frontmatter":{"categories":"CS","title":"CPU 코어와 스레드","date":"January 22, 2022"}},"next":{"fields":{"slug":"/iOS-roadmap/"}},"previous":{"fields":{"slug":"/iOS-MVC/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}