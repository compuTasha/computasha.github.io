{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/CS-dynamic-binding/",
    "result": {"data":{"cur":{"id":"4697998b-f823-5fe1-8576-4d3d2bacca32","html":"<h2 id=\"️-바인딩이란\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%B4%EB%9E%80\" aria-label=\"️ 바인딩이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⛓️ 바인딩이란?</h2>\n<p>함수를 컴파일하면, 선언된 함수의 코드는 메모리에 저장되고 함수 호출문에는 코드의 메모리 주소값이 저장된다.</p>\n<p>여기서 프로그램을 실행하면 함수 호출문에서 함수 코드가 저장된 주소로 이동한 후 함수를 실행하고 원래 위치로 돌아오는데</p>\n<p>이때 함수 호출문에서 함수 코드가 저장된 주소로 <strong>연결</strong>하는 과정을 바인딩이라고 한다.</p>\n<br>\n<h2 id=\"-동적-바인딩\" style=\"position:relative;\"><a href=\"#-%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\" 동적 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🏃🏻 동적 바인딩</h2>\n<p><code class=\"language-text\">동적 바인딩</code>의 경우,  컴파일 과정에서는 부모 클래스의 함수를 참조하지만 <strong>런타임 과정에서 실제로는 자식 클래스의 함수와 바인딩된다.</strong></p>\n<h3 id=\"왜\" style=\"position:relative;\"><a href=\"#%EC%99%9C\" aria-label=\"왜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜?</h3>\n<p><code class=\"language-text\">정적 바인딩</code>의 경우, 컴파일 과정에서 정의된 타입 형식을 참조해서 어떤 클래스와 메소드를 참조할지 결정하는데(=super class의 메소드)</p>\n<p><code class=\"language-text\">동적 바인딩</code>의 경우에는 런타임에 실제 객체를 찾으니까 <strong>오버라이드된 자식 클래스의 메소드의 결과가 출력된다.</strong></p>\n<p>→ 다형성(Polymorphism)을 잘 보여준다</p>\n<p>(컴파일러는 static method에 대해 실제 객체를 찾는 작업을 하지 않음)</p>\n<br>\n<ul>\n<li>대부분의 객체 지향 언어가 <code class=\"language-text\">동적 바인딩</code>을 지원한다<details><summary>물론 예외도 있음</summary><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVQoz52S6Y6jQAyEef/H21Eumr5hYLI5IEAC5PhW7mhm/m9LVrXscrna6qyqSqzzHNuJ623m8Xjwer3435NdpwfN345Y7XHO4b2nqWvG60w/LozjSN9f6Puey+WNt9vtfR+FMzFIfZxY7i+yYztShANaG4wx+HJPrgqUtphwwMQDxjistRSFTgOrz0+01rhYY1xEFwptA5fhSta1LdtdzsfHH3JlUNqzWq/ZbCQ2Kbfb5Wy3W4qiwBjLarXGeY9SeeKthZfvGPqe7HQ6JXc27Allg3UhuRG3IvC9BnEkYoLW6FRvmi+GYaDrurSa5/NJdjiP2NDgQ6CwEV+dKKs6iYhYXTc/ojJAeMpEXIgYqTcNMUacD5zbjqztepRSOGsT5koRwq9LIQuKqEQsS6yvOcbI3prUJz3yU4bxRnY8t1TWMlYVX94nByIiIc9ZloV5nn/xvrDME895hvudaZre+Vm+3J1/Jb5T23WH4igAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"에이다\"\n        title=\"에이다\"\n        src=\"/static/04de91bf8064c007dfe88d74cd7be1b1/37523/Ada.png\"\n        srcset=\"/static/04de91bf8064c007dfe88d74cd7be1b1/e9ff0/Ada.png 180w,\n/static/04de91bf8064c007dfe88d74cd7be1b1/f21e7/Ada.png 360w,\n/static/04de91bf8064c007dfe88d74cd7be1b1/37523/Ada.png 720w,\n/static/04de91bf8064c007dfe88d74cd7be1b1/302a4/Ada.png 1080w,\n/static/04de91bf8064c007dfe88d74cd7be1b1/0e904/Ada.png 1384w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></details></li>\n</ul>\n<br>\n<p>필요에 따라 정적 바인딩과 동적 바인딩을 섞어서 쓰는 것 같다.</p>\n<br>\n<h3 id=\"정적동적-타입과-정적동적-바인딩은-다른-개념\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85%EA%B3%BC-%EC%A0%95%EC%A0%81%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%80-%EB%8B%A4%EB%A5%B8-%EA%B0%9C%EB%85%90\" aria-label=\"정적동적 타입과 정적동적 바인딩은 다른 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적/동적 타입과 정적/동적 바인딩은 다른 개념</h3>\n<p>정적 타입의 언어는 컴파일 시 변수의 타입이 결정되고, 동적 타입의 언어는 런타임 시 변수의 타입이 결정된다.</p>\n<p><a href=\"https://blog.naver.com/tor012/222202064976\">정적타입 vs 동적타입 (Static type.. : 네이버블로그 (naver.com)</a></p>\n<p>→ 동적 언어는 동적 타입을 지원하는 언어를 뜻함<br>\n(e.g. 코틀린은 정적 언어. 따라서 컴파일 시점에 모든 객체나 메서드의 타입을 알 수 있다. 파이썬은 동적 언어. 따라서 런타임에 타입이 결정되고 이 때문에 정수형으로 선언된 변수가 문자형으로도 저장될 수 있다.)</p>\n<br>\n<h3 id=\"동적-언어의-강타입언어와-약타입언어\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%A0%81-%EC%96%B8%EC%96%B4%EC%9D%98-%EA%B0%95%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4%EC%99%80-%EC%95%BD%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4\" aria-label=\"동적 언어의 강타입언어와 약타입언어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동적 언어의 강타입언어와 약타입언어</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAqUlEQVQY031Q2wqFMAzb/3/ivE3nZeIFYexpag4pDPriGYSmLU27GO89pmnCsixo2xZN04A15xyGYZB6jBF87/t+ovTNOI4iGEIAOQWYkx/HgZwznufBv6dFzX3fIDiouRZiZJ2xQOda2PAifq/ve2zbhrquBbyQFnRdJzaQ0wrm1lpUVSWWECklOUAu3Pcd8zwLruuSIWJdVxR/2eNinVO41Ln8PE8R/AECeXyAPuSBZwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"강타입,약타입\"\n        title=\"강타입,약타입\"\n        src=\"/static/c466e6501bbbf1593eecdb6b0dc57783/37523/Untitled.png\"\n        srcset=\"/static/c466e6501bbbf1593eecdb6b0dc57783/e9ff0/Untitled.png 180w,\n/static/c466e6501bbbf1593eecdb6b0dc57783/f21e7/Untitled.png 360w,\n/static/c466e6501bbbf1593eecdb6b0dc57783/37523/Untitled.png 720w,\n/static/c466e6501bbbf1593eecdb6b0dc57783/302a4/Untitled.png 1080w,\n/static/c466e6501bbbf1593eecdb6b0dc57783/51800/Untitled.png 1196w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><a href=\"https://redthing.tistory.com/entry/%EC%A0%95%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4-Python\">https://redthing.tistory.com/entry/정적-타입-언어-동적-타입-언어-Python</a></p>\n<br>\n<p>아우 어렵다..!</p>\n<br>\n<details>\n<summary>참고 링크</summary>\n<p><a href=\"https://secretroute.tistory.com/entry/140819\">정적 바인딩(Static binding) vs. 동적 바인딩(Dynamic binding)</a></p>\n<p><a href=\"https://brunch.co.kr/@mystoryg/60\">다형성과 동적 바인딩</a></p>\n<p><a href=\"https://woovictory.github.io/2020/07/05/Java-binding/\">[Java] 동적바인딩 vs 정적바인딩</a></p>\n<p><a href=\"https://leemoney93.tistory.com/63\">C++ 정적 바인딩, 동적 바인딩</a></p>\n</details>\n<p><br><br></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%B4%EB%9E%80\">⛓️ 바인딩이란?</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\">🏃🏻 동적 바인딩</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C\">왜?</a></li>\n<li><a href=\"#%EC%A0%95%EC%A0%81%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85%EA%B3%BC-%EC%A0%95%EC%A0%81%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%80-%EB%8B%A4%EB%A5%B8-%EA%B0%9C%EB%85%90\">정적/동적 타입과 정적/동적 바인딩은 다른 개념</a></li>\n<li><a href=\"#%EB%8F%99%EC%A0%81-%EC%96%B8%EC%96%B4%EC%9D%98-%EA%B0%95%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4%EC%99%80-%EC%95%BD%ED%83%80%EC%9E%85%EC%96%B8%EC%96%B4\">동적 언어의 강타입언어와 약타입언어</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"⛓️ 바인딩이란? 함수를 컴파일하면, 선언된 함수의 코드는 메모리에 저장되고 함수 호출문에는 코드의 메모리 주소값이 저장된다. 여기서 프로그램을 실행하면 함수 호출문에서 함수 코드가 저장된 주소로 이동한 후 함수를 실행하고 원래 위치로 돌아오는데 이때 함수 호출문에서 함수 코드가 저장된 주소로 연결하는 과정을 바인딩이라고 한다. 🏃🏻 동적 바인딩 의 경우,  컴파일 과정에서는 부모 클래스의 함수를 참조하지만 런타임 과정에서 실제로는 자식 클래스의 함수와 바인딩된다. 왜? 의 경우, 컴파일 과정에서 정의된 타입 형식을 참조해서 어떤 클래스와 메소드를 참조할지 결정하는데(=super class의 메소드) 의 경우에는 런타임에 실제 객체를 찾으니까 오버라이드된 자식 클래스의 메소드의 결과가 출력된다. → 다형성(Polymorphism)을 잘 보여준다 (컴파일러는 static method에 대해 실제 객체를 찾는 작업을 하지 않음) 대부분의 객체 지향 언어가 을 지원한다물론 예외도 있음 필요…","frontmatter":{"date":"February 16, 2022","title":"정적/동적 바인딩, 정적/동적 타입","categories":"CS","author":"콤퓨타샤","emoji":"⛓️"},"fields":{"slug":"/CS-dynamic-binding/"}},"next":{"id":"5cc9e5c2-c682-5e48-b20f-49111f5873fe","html":"<p>프로그래밍 패러다임과 함수형 프로그래밍에 관해서는 <a href=\"https://computasha.github.io/CS-functional-programming/\">여기</a>를 참고해주세요!</p>\n<br>\n<h2 id=\"oop란\" style=\"position:relative;\"><a href=\"#oop%EB%9E%80\" aria-label=\"oop란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOP란?</h2>\n<p>객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, ‘객체’들의 상호작용(메시지 주고받기, 데이터 처리 등)으로 프로그램 로직을 구성하는 프로그래밍 패러다임이다.</p>\n<br>\n<blockquote>\n<p>💡 <strong>프로그래밍 패러다임</strong></p>\n<p><a href=\"https://computasha.github.io/CS-functional-programming/\">프로그래밍 패러다임(Programming Paradigm)</a>은 프로그래머에게 프로그래밍의 관점을 갖게 하고 코드를 어떻게 작성할지 결정하는 역할을 한다. 새로운 프로그래밍 패러다임을 통해서는 새로운 방식으로 생각하는 법을 배우게 되고, 이를 바탕으로 코드를 작성하게 된다.</p>\n</blockquote>\n<br>\n<h2 id=\"oop의-특징\" style=\"position:relative;\"><a href=\"#oop%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"oop의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOP의 특징</h2>\n<h3 id=\"1-캡슐화-encapsulation-\" style=\"position:relative;\"><a href=\"#1-%EC%BA%A1%EC%8A%90%ED%99%94-encapsulation-\" aria-label=\"1 캡슐화 encapsulation  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 캡슐화, Encapsulation 💊</h3>\n<p>한 객체가 <strong>특정한 하나의 목적</strong>을 위해 필요한 데이터나 메소드를 하나로 묶는 것을 의미한다</p>\n<ul>\n<li>데이터는 외부에서 직접 접근을 하면 안되고 함수를 통해서만 접근해야 한다</li>\n</ul>\n<br>\n<h3 id=\"2-은닉화-information-hiding-\" style=\"position:relative;\"><a href=\"#2-%EC%9D%80%EB%8B%89%ED%99%94-information-hiding-\" aria-label=\"2 은닉화 information hiding  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 은닉화, Information hiding 🥷</h3>\n<p>캡슐화의 목표.\n내부 구조는 private하게 감춰두고 외부에서 조작할 수 있는 정보만 public으로 공개한다</p>\n<p>→ 바깥 간섭으로 인해 발생하는 오류 방지<br>\n(<a href=\"http://wiki.hash.kr/index.php?title=%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D&#x26;mobileaction=toggle_view_desktop#.EC.83.81.EC.86.8D\">내부의 구현은 감추고 모듈 내에서의 응집도를 높이며, 외부로의 노출을 최소화하여 모듈 간의 결합도를 떨어뜨려 유연함과 유지 보수성을 높인다</a>)</p>\n<p>→ 다른 사람의 클래스 객체를 다 뜯어볼 필요가 없어진다. 제공되는 기능 그대로 사용하면 된다</p>\n<br>\n<h3 id=\"3-상속-inheritance-\" style=\"position:relative;\"><a href=\"#3-%EC%83%81%EC%86%8D-inheritance-\" aria-label=\"3 상속 inheritance  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 상속, Inheritance 👪</h3>\n<p>기존 메소드와 변수를 물려받되, 필요한 기능을 더 추가하거나 나(자식클래스)에게 맞게 재정의하는 방법</p>\n<p>상속과 인터페이스를 이해하는데 가장 큰 도움이 된 <a href=\"https://youtu.be/vrhIxBWSJ04\">영상</a>에 나왔던 예시<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVQoz42SW2/CMAyF+f//ir1MYmidNO4at1FouRVYr6njflNaQGjiYZaS2MfOiU+SVlVVVBW49dEa/Hnurz3mW1Wzow7iOKbf7zEY9LFWXGmNqyofnsd67SMiRFFEsNkQBMGd7La23GS1CZI0YzSeMJsvsNcClyvF1thuf6AwJefTiTDcst8fUK3Qq5qaUFTJpMIP9wwmXxzOP0yXPr3hhNUmJDVCaizz1YZgdyCTW9/PpbcKsVhgPpvy2nknyQzj0ZCXdpuu90lRWtQKnc4bk+mSUiFKS7rfF0ZhwuKY4/kxxmrToRGlkCbYxpYoNvcTg4twSaX2XcnqaIhzIRflkgtxYcmMrX29SXZ3lBhby3LysrLxk0Ka2OFXzPmORPSZ6OYe60dx7I74P0MfXvX2pfI8J0kSjDH8Amb/bN41tV51AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"상속과 인터페이스\"\n        title=\"상속과 인터페이스\"\n        src=\"/static/7abbb433459f6103db01f9f9a8937ad5/37523/inheritance-interface.png\"\n        srcset=\"/static/7abbb433459f6103db01f9f9a8937ad5/e9ff0/inheritance-interface.png 180w,\n/static/7abbb433459f6103db01f9f9a8937ad5/f21e7/inheritance-interface.png 360w,\n/static/7abbb433459f6103db01f9f9a8937ad5/37523/inheritance-interface.png 720w,\n/static/7abbb433459f6103db01f9f9a8937ad5/302a4/inheritance-interface.png 1080w,\n/static/7abbb433459f6103db01f9f9a8937ad5/07a9c/inheritance-interface.png 1440w,\n/static/7abbb433459f6103db01f9f9a8937ad5/c549b/inheritance-interface.png 2128w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n상속이 👪 이런 느낌이라면, 인터페이스는 👬 이런 느낌.</p>\n<ul>\n<li>보통 상속에서는 다중 상속은 안되거나 제한이 있는데(클래스 상속 관계에 혼란을 줄 수 있어서), 인터페이스는 이에 대해 자유롭다</li>\n<li>날기 인터페이스를 implements 하는 경우, 반드시 날기 인터페이스에 있는 메소드를 정의해야 한다</li>\n<li>인터페이스의 경우 implements된 모든 클래스 객체를 하나로 묶어서 한번에 명령 할 수 있다 → 짱 편함</li>\n</ul>\n<p>e.g. 박쥐와 날다람쥐는 포유류 클래스로부터 새끼 수 데이터, 수유하는 방법 메소드와 같은 내용을 상속받되, 원하는 내용을 추가하거나 재정의할 수 있다. 그리고 공통적으로 날기 인터페이스를 implements 했기 때문에 이 인터페이스에 있는 날기 메소드를 각자 나는 방법에 맞게 정의해야 한다.</p>\n<br>\n<h3 id=\"4-추상화-abstraction-️\" style=\"position:relative;\"><a href=\"#4-%EC%B6%94%EC%83%81%ED%99%94-abstraction-%EF%B8%8F\" aria-label=\"4 추상화 abstraction ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 추상화, Abstraction ⛰️</h3>\n<p>공통의 속성이나 기능을 묶어 이름을 붙이는 것이다</p>\n<p>→ 보통 객체 지향 프로그래밍에서 클래스를 정의하는 걸 추상화라고 생각하면 된다</p>\n<br>\n<h3 id=\"5-다형성-polymorphism-\" style=\"position:relative;\"><a href=\"#5-%EB%8B%A4%ED%98%95%EC%84%B1-polymorphism-\" aria-label=\"5 다형성 polymorphism  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 다형성, Polymorphism 🎭</h3>\n<p>하나의 변수명이 상황에 따라 다른 의미로 해석될 수 있다는 것을 뜻한다</p>\n<ul>\n<li>일반적으로 오버라이딩 혹은 오버로딩을 의미한다</li>\n</ul>\n<br>\n<h3 id=\"6-동적-바인딩-️\" style=\"position:relative;\"><a href=\"#6-%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9-%EF%B8%8F\" aria-label=\"6 동적 바인딩 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 동적 바인딩 ⛓️</h3>\n<p>runtime에 값에 따라 변수 데이터 타입, 호출될 함수가 결정된다</p>\n<ul>\n<li>대부분의 객체 지향 언어가 동적 바인딩을 지원하지만 에이다 같은 예외도 있다</li>\n</ul>\n<p>→ 자세한 내용은 다음 글에..!<br>\n<a href=\"https://computasha.github.io/CS-dynamic-binding/\">‘정적/동적 바인딩, 정적/동적 타입’</a></p>\n<p><br><br></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#oop%EB%9E%80\">OOP란?</a></p>\n</li>\n<li>\n<p><a href=\"#oop%EC%9D%98-%ED%8A%B9%EC%A7%95\">OOP의 특징</a></p>\n<ul>\n<li><a href=\"#1-%EC%BA%A1%EC%8A%90%ED%99%94-encapsulation-\">1. 캡슐화, Encapsulation 💊</a></li>\n<li><a href=\"#2-%EC%9D%80%EB%8B%89%ED%99%94-information-hiding-\">2. 은닉화, Information hiding 🥷</a></li>\n<li><a href=\"#3-%EC%83%81%EC%86%8D-inheritance-\">3. 상속, Inheritance 👪</a></li>\n<li><a href=\"#4-%EC%B6%94%EC%83%81%ED%99%94-abstraction-%EF%B8%8F\">4. 추상화, Abstraction ⛰️</a></li>\n<li><a href=\"#5-%EB%8B%A4%ED%98%95%EC%84%B1-polymorphism-\">5. 다형성, Polymorphism 🎭</a></li>\n<li><a href=\"#6-%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9-%EF%B8%8F\">6. 동적 바인딩 ⛓️</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"February 12, 2022","title":"객체 지향 프로그래밍, OOP의 개념과 특징","categories":"CS","author":"콤퓨타샤","emoji":"🤙🏻"},"fields":{"slug":"/CS-OOP/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://computasha.github.io","comments":{"utterances":{"repo":"compuTasha/blog-comments"}}}}},"pageContext":{"slug":"/CS-dynamic-binding/","nextSlug":"/CS-OOP/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}